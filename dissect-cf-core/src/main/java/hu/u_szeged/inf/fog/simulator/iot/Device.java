package hu.u_szeged.inf.fog.simulator.iot;

import java.util.ArrayList;
import java.util.List;
import hu.mta.sztaki.lpds.cloud.simulator.DeferredEvent;
import hu.mta.sztaki.lpds.cloud.simulator.Timed;
import hu.mta.sztaki.lpds.cloud.simulator.energy.specialized.PhysicalMachineEnergyMeter;
import hu.mta.sztaki.lpds.cloud.simulator.iaas.resourcemodel.ResourceConsumption;
import hu.mta.sztaki.lpds.cloud.simulator.iaas.resourcemodel.ResourceConsumption.ConsumptionEvent;
import hu.mta.sztaki.lpds.cloud.simulator.io.NetworkNode;
import hu.mta.sztaki.lpds.cloud.simulator.io.Repository;
import hu.mta.sztaki.lpds.cloud.simulator.io.StorageObject;
import hu.mta.sztaki.lpds.cloud.simulator.io.NetworkNode.NetworkException;
import hu.u_szeged.inf.fog.simulator.application.Application;
import hu.u_szeged.inf.fog.simulator.iot.actuator.Actuator;
import hu.u_szeged.inf.fog.simulator.iot.mobility.GeoLocation;
import hu.u_szeged.inf.fog.simulator.physical.MicroController;

/**
 * The goal of this class is to ensure an abstract parent class 
 * with the most frequently used characteristics for various type of IoT devices.
 */
public abstract class Device extends Timed {

    /**
     * It is highly required to reach each created IoT device in a common static list.
     */
    public static List < Device > allDevices = new ArrayList < Device > ();
    
    /**
     * It represents the actual position of this device.
     */
    public GeoLocation geoLocation;

    /**
     * Reference to an IoT application which receives the sensor data generated by a child class.
     */
    public Application app;

    /** 
     * When the IoT device starts the data sensing and sending process (in milliseconds).
     */
    public long startTime;

    /** 
     * When the IoT device stops the data sensing and sending process (in milliseconds).
     */
    public long stopTime;

    /**
     * It tells us how many sensors the current IoT device has.
     */
    public int sensorCount;

    /**
     * The size of one measurement (in bytes).
     */
    public long fileSize;

    /**
     * When a device starts working, it is required to determine which IoT application the current IoT device communicates with.
     */
    public DeviceStrategy deviceStrategy;

    /**
     * A helper variable to count how many messages the device already created.
     */
    public int messageCount;
    
    /**
	 * It represents the actuator interface which handle the mobility and events requiring actuating.
	 */
	public Actuator actuator;

    /**
     * The repository, which the data will be forwarded to.
     */
    public Repository nodeRepository;

    /**
     * The physical properties of the device, i.e. CPU, memory, network.
     */
    public MicroController mc;

    /**
     * The delay for a data packet to travel (in milliseconds).
     */
    public int latency;

    /**
     * A helper variable to count how many bytes the device already created.
     */
    public long sumOfGeneratedData;

    /**
     * The time interval between two sensor measurement (in milliseconds). 
     */
    public long freq;

    /**
     * The length of one measurement of a sensor (in milliseconds). 
     * It is also the frequency of the energy measurement.
     */
    public long sensorFreq;

    /**
     * The consumed energy of the device (in Watts).
     */
    public double energyConsumption;

    /**
     * A helper variable which tells if the energy measuring is on or off.
     */
    public boolean readEnergy;

    /**
     * It starts the working of the device deferred according to the start time and the delay. 
     * From that moment the device will repeat the data generating and sending process until the stop time by the its frequency.
     * Occasionally it also starts the energy measurement as well.
     */
    protected void startMeter() {
        if (this.isSubscribed() == false) {
            Device d = this;
            new DeferredEvent(this.startTime) {

                @Override
                protected void eventAction() {
                    subscribe(freq);
                    mc.setStateToRunning();
                   // nodeRepository = app.computingAppliance.iaas.repositories.get(0);
                    if (readEnergy) {
                        readEnergy(d);
                    }
                }
            };
        }
    }
    
    /**
     * It sends all data located in the local repository. 
     */
    protected void startCommunicate() throws NetworkException {
        for (StorageObject so: this.mc.localDisk.contents()) {
            DeviceDataEvent soe = new DeviceDataEvent(so);
            NetworkNode.initTransfer(so.size, ResourceConsumption.unlimitedProcessing, this.mc.localDisk, this.nodeRepository, soe);
        }
    }
    
    /**
     * It stops the station totally.
     */
    protected void stopMeter() {
        unsubscribe();
        this.mc.setStateToOff();
    }

    /**
     * The class collects the results of the energy measurements.
     * @param d The device which consumes energy during its lifetime. 
     */
    protected void readEnergy(Device d) {
        final PhysicalMachineEnergyMeter pmm = new PhysicalMachineEnergyMeter(this.mc);
        
        /**
         * A helper class to log the energy measurement. 
         */
        class DeviceEnergyCollector extends Timed {

            /**
             * It starts the logging of the energy measurement.
             */
            private void start() {
                subscribe(sensorFreq);
            }

            /**
             * It stops the logging of the energy measurement.
             */
            private void stop() {
                unsubscribe();
            }

            /**
             * This recurring method  to calculate the actual energy consumption.
             */
            @Override
            public void tick(final long fires) {
                energyConsumption = pmm.getTotalConsumption();
                if (!d.isSubscribed()) {
                    this.stop();
                    pmm.stopMeter();
                }
            }
        }
        
        final DeviceEnergyCollector mdc = new DeviceEnergyCollector();
        pmm.startMeter(sensorFreq, true);
        mdc.start();
    }

    /**
     * The event which handles if the data sending was successful or unsuccessful. 
     */
    protected class DeviceDataEvent implements ConsumptionEvent {

        /**
         * The data which is intended to send.
         */
        private StorageObject so;

        /**
         * Constructs the event, thus we can check if the data sending was OK.
         * @param so The data (file) which will be forwarded. 
         */
        protected DeviceDataEvent(StorageObject so) {
            this.so = so;
        }

        /**
         * The method removes the data from the local repository when the data arrives to the target.
         */
        @Override
        public void conComplete() {
            mc.localDisk.deregisterObject(this.so);
            app.sumOfArrivedData += this.so.size;
        }

        /**
         * The method is called if the data registration was unsuccessful.
         * Currently it is failure and the simulation stops. It mainly happen because of the too small repository size. 
         */
        @Override
        public void conCancelled(ResourceConsumption problematic) {
            try {
                System.err.println("WARNING: Deleting StorageObject from local repository is unsuccessful!");
                System.exit(0); // TODO: it should not be an error.
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

    }

}