package hu.u_szeged.inf.fog.simulator.application;

import java.util.ArrayList;
import java.util.List;
import hu.mta.sztaki.lpds.cloud.simulator.Timed;
import hu.mta.sztaki.lpds.cloud.simulator.iaas.PhysicalMachine;
import hu.mta.sztaki.lpds.cloud.simulator.iaas.PhysicalMachine.ResourceAllocation;
import hu.mta.sztaki.lpds.cloud.simulator.iaas.VirtualMachine;
import hu.mta.sztaki.lpds.cloud.simulator.iaas.VirtualMachine.StateChangeException;
import hu.mta.sztaki.lpds.cloud.simulator.iaas.resourcemodel.ConsumptionEventAdapter;
import hu.mta.sztaki.lpds.cloud.simulator.iaas.resourcemodel.ResourceConsumption;
import hu.mta.sztaki.lpds.cloud.simulator.iaas.resourcemodel.ResourceConsumption.ConsumptionEvent;
import hu.mta.sztaki.lpds.cloud.simulator.io.NetworkNode;
import hu.mta.sztaki.lpds.cloud.simulator.io.NetworkNode.NetworkException;
import hu.mta.sztaki.lpds.cloud.simulator.io.StorageObject;
import hu.u_szeged.inf.fog.simulator.iot.Device;
import hu.u_szeged.inf.fog.simulator.physical.ComputingAppliance;
import hu.u_szeged.inf.fog.simulator.providers.Instance;
import hu.u_szeged.inf.fog.simulator.providers.Provider;
import hu.u_szeged.inf.fog.simulator.util.TimelineGenerator.TimelineCollector;
import hu.vio.simulator.DataRegressionTesterScenario;

/**
 * This class represents an IoT application, which processes the data generated by IoT devices.
 * Each application entity run on a computing node (e.g. cloud or fog).
 * During the simulation the unprocessed data are allocated to a group of VMs to be processed until the data flow is empty. 
 */
public class Application extends Timed {
	
	/**
	 * It contains all applications which were created.
	 */
    public static ArrayList < Application > allApplication = new ArrayList < Application > ();

    /**
     * It count how much time the data traveled during the application on the network.
     */
    public static long sumOfTimeOnNetwork = 0;
    
    /**
     * It count how many data traveled during the application on the network.
     */
    public static long sumOfByteOnNetwork = 0;
    
    /**
     * A list containing IoT devices which send data directly to this application.
     */
	public List < Device > deviceList;

	/**
	 * Each application manages a group of VMs, this list contains the members of this group.
	 */
    public ArrayList < VmCollector > vmCollectorList;

    /**
     * The maximum number of instructions (executed on a VM) which a fully loaded task represents.
     */
    public double countOfInstructions;

    /**
     * The incoming data are organized into task, this defines the maximum size of a task.
     */
    public long taskSize;

    /**
     * The application runs on this computational resources (e.g. cloud or fog).
     */
    public ComputingAppliance computingAppliance;

    /**
     * The name of the application.
     */
    public String name;

    /**
     * The object contains the VM properties such as cost, flavor and image.
     */
    public Instance instance;

    /**
     * A dedicated member of the group of VMs, which represents a gatway service between an IoT device and an application.
     */
    public VmCollector broker;

    /**
     * The time interval between two data (task) allocation to VMs.
     */
    public long freq;

    /**
     * Defines how many data will be transfered to an other application.
     */
    public long dataForTransfer;
    /**
     * The full active time of the application.
     */
    public long sumOfWorkTime;

    /**
     * All data which were already processed.
     */
    public long sumOfProcessedData;
    
    /**
     * All data which arrived from IoT device/other application.
     */
    public long sumOfArrivedData;

    /**
     * The count of tasks which are currently under processing.
     */
    public int currentTask;

    /**
     * It contains the time when the last task was finished.
     */
    public long stopTime;

    /**
     * Above this number, the unallocated task may be forwarded to an other node.
     */
    public int threshold;

    /**
     * A counter which increased if there is at least one incoming data package from another application.
     */
    public int incomingData;

    /**
     * It defines the policy which determines which node the unallocated tasks to be forwarded to.
     */
    public String strategy;

    /**
     * List of providers for the IoT side cost calculations.
     */
    public ArrayList < Provider > providers;

    /**
     * True, if the application can receive IoT data directly.
     */
    public boolean canJoin;

    /**
     * It collects information about the tasks done (e.g. when it started/ended, how much time it takes).
     * Only for visualizing the simulation. 
     */
    public ArrayList < TimelineCollector > timelineList = new ArrayList < TimelineCollector > ();

    /**
     * Constructs an IoT application. Applications run on cloud of fog nodes and some of them are connected. This means that 
     * off-loading decisions may help to reach faster data processing.
     * @param freq The time interval between two data (task) allocation to VMs.
     * @param taskSize The incoming data are organized into task, this defines the maximum size of a task.
     * @param instance The object contains the VM properties such as cost, flavor and image.
     * @param name The name of the application.
     * @param countOfInstructions The maximum number of instructions (executed on a VM) which a fully loaded task represents.
     * @param threshold Above this number, the unallocated task may be forwarded to an other node.
     * @param strategy It defines the policy which determines which node the unallocated tasks to be forwarded.
     * @param canJoin True, if the application can receive IoT data directly.
     */
    public Application(long freq, long taskSize, String instance, String name, double countOfInstructions, int threshold,
        String strategy, boolean canJoin) {
        Application.allApplication.add(this);
        this.deviceList = new ArrayList < Device > ();
        this.vmCollectorList = new ArrayList < VmCollector > ();
        this.providers = new ArrayList < Provider > ();
        this.instance = Instance.instances.get(instance);
        this.taskSize = taskSize;
        this.threshold = threshold;
        this.countOfInstructions = countOfInstructions;
        this.strategy = strategy;
        this.name = name;
        this.freq = freq;
        this.canJoin = canJoin;
        subscribe(this.freq);
    }

    /**
     * This class represents a VM and its characteristics that to be reusable for the IoT application.
     */
    public class VmCollector {

    	/**
    	 * The host machine of this VM.
    	 */
    	public PhysicalMachine pm;
    	
    	/**
    	 * Reference to the VM.
    	 */
        public VirtualMachine vm;
        
        /**
         * True, if the VM executes a task currently.
         */
        public boolean isWorking;
        
        /**
         * Counts the tasks, which are already done by this VM.
         */
        public int taskCounter;
        
        /**
         * The last time when the VM was under load.
         */
        public long lastWorked;
        
        /**
         * The total time of the VM executing tasks.
         */
        public long workTime;
        
        /**
         * The ID of the VM.
         */
        public String id;
        
        /**
         * The time when the VM was created.
         */
        public long installed;
        
        /**
         * Counts how many times the VM was restarted.
         */
        public int restarted;
 
        /**
         * It constructs a collection of properties dedicated to a VM.
         * @param vm The VM which should be reusable for the IoT application.
         */
        VmCollector(VirtualMachine vm) {
            this.vm = vm;
            this.lastWorked = Timed.getFireCount();
            this.installed = Timed.getFireCount();
            this.id = Integer.toString(vmCollectorList.size());
        }
        
    }

    /**
     * Checks if there is at least one device (which send the data to this application) subscribed
     * (returning with false in that case).
     */
    private boolean checkDeviceState() {
        for (Device d : this.deviceList) {
            if (d.isSubscribed()) {
                return false;
            }
        }
        return true;
    }

    /**
     * It registers the computational node for this application with the virtual image file as well.
     * @param ca The node which will serve under this application.
     */
    public void setComputingAppliance(ComputingAppliance ca) {
        this.computingAppliance = ca;
        this.computingAppliance.iaas.repositories.get(0).registerObject(this.instance.va);
        this.startBroker();
    }

    /**
     * It creates a dedicated VM for acting as a gateway between an IoT device/IoT application and this application.
     */
    private void startBroker() {
    	try {
            VirtualMachine vm = this.computingAppliance.iaas.requestVM(this.instance.va,
                this.instance.arc, this.computingAppliance.iaas.repositories.get(0), 1)[0];
            if (vm != null) {
                VmCollector vmc = new VmCollector(vm);
                vmc.id = "broker";
                this.vmCollectorList.add(vmc);
                this.broker = vmc;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * It search for a free VM which is able to start the task processing.
     */
    private VmCollector VmSearch() {
        for (int i = 0; i < this.vmCollectorList.size(); i++) {
            if (this.vmCollectorList.get(i).isWorking == false && 
            		this.vmCollectorList.get(i).vm.getState().equals(VirtualMachine.State.RUNNING) &&
                    !this.vmCollectorList.get(i).id.equals("broker")) {
                return this.vmCollectorList.get(i);
            }
        }
        return null;
    }

    /**
     * If there is no available VM, it creates a new one.
     */
    private boolean generateAndAddVM() {
        try {
            if (this.turnonVM() == false) {
                for (PhysicalMachine pm: this.computingAppliance.iaas.machines) {
                    if (pm.isReHostableRequest(this.instance.arc)) {
                        VirtualMachine vm = pm.requestVM(this.instance.va, this.instance.arc,
                            this.computingAppliance.iaas.repositories.get(0), 1)[0];
                        if (vm != null) {
                            VmCollector vmc = new VmCollector(vm);
                            vmc.pm = pm;
                            this.vmCollectorList.add(vmc);
                            //@ VIO_REMOVED_COMMENT @ System.out.print(" asked new VM");
                            return true;
                        }
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return false;
    }

    /**
     * Looks for the first VM, which can be restarted immediately.
     * Returns false if it did not find any.   
     * TODO: turn on as many VMs as needs based on the ratio of unprocessed data and task size.
     */
    private boolean turnonVM() {
        for (int i = 0; i < this.vmCollectorList.size(); i++) {
            if (this.vmCollectorList.get(i).vm.getState().equals(VirtualMachine.State.SHUTDOWN) &&
                this.vmCollectorList.get(i).pm.isReHostableRequest(this.instance.arc)) {
                try {
                    ResourceAllocation ra = this.vmCollectorList.get(i).pm.allocateResources(this.instance.arc,
                        false, PhysicalMachine.defaultAllocLen);
                    this.vmCollectorList.get(i).restarted++;
                    this.vmCollectorList.get(i).vm.switchOn(ra, null);
                    this.vmCollectorList.get(i).lastWorked = Timed.getFireCount();
                    //@ VIO_REMOVED_COMMENT @ System.out.print(" turned on VM");
                    return true;
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        return false;
    }

    /**
     * It turns off as many unused VMs as it can.
     */
    private void turnoffVM() {
        for (VmCollector vmcl: this.vmCollectorList) {
            if (vmcl.vm.getState().equals(VirtualMachine.State.RUNNING) && !vmcl.id.equals("broker") &&
                vmcl.isWorking == false) {
                try {
                    vmcl.vm.switchoff(false);
                } catch (StateChangeException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    /**
     * Calculates the actual cost of the application based on its working time. 
     */
    public double getCurrentCost() {
        return this.instance.calculateCloudCost(this.sumOfWorkTime);
    }

    /**
     * It updates the working time of the VMs and the IoT application as well.
     */
    private void countVmRunningTime() {
        for (VmCollector vmc: this.vmCollectorList) {
            if (vmc.vm.getState().equals(VirtualMachine.State.RUNNING)) {
                vmc.workTime += (Timed.getFireCount() - vmc.lastWorked);
                this.sumOfWorkTime += (Timed.getFireCount() - vmc.lastWorked);
                vmc.lastWorked = Timed.getFireCount();
            }
        }
    }

    /**
     * The method selects the proper application to forward a certain amount of data according to the application strategy.
     * You cannot start a simulation with unknown strategy.
     */
    private void strategy(long unprocessedData) {
        DataRegressionTesterScenario.predictor.predict();
        if (this.strategy.equals("random")) {
            new RandomApplicationStrategy(this, unprocessedData);
        } else if (this.strategy.equals("hold")) {
            new HoldDownApplicationStrategy(this, unprocessedData);
        } else if (this.strategy.equals("push")) {
            new PushUpApplicationStrategy(this, unprocessedData);
        } else if (this.strategy.equals("load")) {
            new LoadApplicationStrategy(this, unprocessedData);
        } else if (this.strategy.equals("fuzzy")) {
            new FuzzyApplicationStrategy(this, unprocessedData);
        } else {
        	System.err.println("WARNING: the application strategy called " + this.strategy + "does not exist!");
            System.exit(0);
        }
    }

    /**
     * It manages the file transfer between IoT applications.
     * @param a Where to send the unprocessed data.
     * @param dataForTransfer How many bytes of data to be sent.
     */
    public void transferToApplication(Application a, long dataForTransfer) {
        final long onNetwork = Timed.getFireCount();
        a.incomingData++;
        this.sumOfArrivedData -= dataForTransfer;
        if (a.isSubscribed()) {
            final long unprocessed = dataForTransfer;
            try {
                NetworkNode.initTransfer(dataForTransfer, ResourceConsumption.unlimitedProcessing,
                    this.computingAppliance.iaas.repositories.get(0), a.computingAppliance.iaas.repositories.get(0),
                    new ConsumptionEvent() {

                        @Override
                        public void conComplete() {
                            a.sumOfArrivedData += unprocessed;
                            a.incomingData--;
                            Application.sumOfTimeOnNetwork += (Timed.getFireCount() - onNetwork);
                            Application.sumOfByteOnNetwork += unprocessed;
                        }

                        @Override
                        public void conCancelled(ResourceConsumption problematic) {
                        	System.err.println("WARNING: File transfer between the applications is unsuccessful!");
                            System.exit(0); // TODO: it should not be an error.
                        }
                    });
            } catch (NetworkException e) {
                e.printStackTrace();
            }
        } else {
            try {
                a.restartApplication();
            } catch (Exception e) {
                e.printStackTrace();
            }
            new BrokerCheck(this, a, dataForTransfer, (a.freq / 2));
        }
    }
    
    public void restartApplication() {
        //@ VIO_REMOVED_COMMENT @ System.out.println("\n" + this.name + " application has been restarted at " + Timed.getFireCount());
        subscribe(this.freq);
        this.startBroker();
    }
    
    /**
     * The recurring event of the application handles the VM management and the task processing.
     */
    public void tick(long fires) {
        long unprocessedData = (this.sumOfArrivedData - this.sumOfProcessedData);
        
        if (unprocessedData > 0) {
            long alreadyProcessedData = 0;
            while (unprocessedData != alreadyProcessedData) {
                DataRegressionTesterScenario.computeNodeManager.tick();
            	long allocatedData;
                if (unprocessedData - alreadyProcessedData > this.taskSize) {
                    allocatedData = this.taskSize;
                } else {
                    allocatedData = (unprocessedData - alreadyProcessedData);
                }

                final VmCollector vml = this.VmSearch();
                if (vml == null) {
                    int ratio = (int)(unprocessedData / this.taskSize);
                    if (ratio >= this.threshold) {
                        strategy(unprocessedData - alreadyProcessedData);
                    }

                    //@ VIO_REMOVED_COMMENT @ System.out
                    //@ VIO_REMOVED_COMMENT @     .print(this.name + " data/VM: " + ratio + " unprocessed after exit: " + unprocessedData + " decision:");
                    this.generateAndAddVM();
                    break;
                }

                try {
                    final double noi = allocatedData == this.taskSize ? this.countOfInstructions :
                        (double)(this.countOfInstructions * allocatedData / this.taskSize);
                    alreadyProcessedData += allocatedData;
                    vml.isWorking = true;
                    this.currentTask++;

                    vml.vm.newComputeTask(noi, ResourceConsumption.unlimitedProcessing, new ConsumptionEventAdapter() {
                        long vmStartTime = Timed.getFireCount();
                        long allocatedDataTemp = allocatedData;
                        double noiTemp = noi;

                        @Override
                        public void conComplete() {
                            vml.isWorking = false;
                            vml.taskCounter++;
                            currentTask--;
                            stopTime = Timed.getFireCount();
                            timelineList.add(new TimelineCollector(vmStartTime, Timed.getFireCount(), vml.id));
                            //@ VIO_REMOVED_COMMENT @ System.out.println(name + " " + vml.id + " started@ " + vmStartTime + " finished@ " +
                            //@ VIO_REMOVED_COMMENT @     Timed.getFireCount() + " with " + allocatedDataTemp + " bytes, lasted " +
                            //@ VIO_REMOVED_COMMENT @     (Timed.getFireCount() - vmStartTime) + " ,noi: " + noiTemp);

                        }
                    });
                    this.sumOfProcessedData += allocatedData;
                } catch (NetworkException e) {
                    e.printStackTrace();
                }
            }
            
            //@ VIO_REMOVED_COMMENT @ System.out.println(" load(%): " + this.computingAppliance.getLoadOfResource());
        }
        
        this.countVmRunningTime();
        this.turnoffVM();
        /* TODO: debug */
        //@ VIO_REMOVED_COMMENT @ System.out.println(this.name);
        //@ VIO_REMOVED_COMMENT @ System.out.println(this.currentTask == 0 );
        //@ VIO_REMOVED_COMMENT @ System.out.println(this.incomingData == 0);
        //@ VIO_REMOVED_COMMENT @ System.out.println(this.sumOfProcessedData == this.sumOfArrivedData);
        //@ VIO_REMOVED_COMMENT @ System.out.println(this.sumOfProcessedData);
        //@ VIO_REMOVED_COMMENT @ System.out.println(this.sumOfArrivedData);
        //@ VIO_REMOVED_COMMENT @ System.out.println(this.checkDeviceState());
       
        if (this.currentTask == 0 && this.incomingData == 0 && this.sumOfProcessedData == this.sumOfArrivedData &&
            this.checkDeviceState()) {
            unsubscribe();

            for (Provider p: this.providers) {
                if (p.isSubscribed()) {
                    p.needsToStop = true;
                }
            }
            StorageObject so = new StorageObject(this.name, this.sumOfProcessedData, false);
            if (!this.computingAppliance.iaas.repositories.get(0).registerObject(so)) {
                this.computingAppliance.iaas.repositories.get(0).deregisterObject(so);
                this.computingAppliance.iaas.repositories.get(0).registerObject(so);
            }

            for (VmCollector vmcl: this.vmCollectorList) {
                try {
                    if (vmcl.vm.getState().equals(VirtualMachine.State.RUNNING)) {
                        if (vmcl.id.equals("broker")) {
                            vmcl.pm = vmcl.vm.getResourceAllocation().getHost();
                        }
                        vmcl.vm.switchoff(false);
                    }
                } catch (StateChangeException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}